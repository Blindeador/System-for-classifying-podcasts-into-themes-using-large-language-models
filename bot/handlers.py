import logging
import json
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, MessageHandler, CallbackQueryHandler, filters

from config import MAX_SEARCH_RESULTS
from bot.utils import is_url, extract_section, format_long_message, store_user_data, get_user_data, clear_user_data, search_spotify_episodes
from bot.audio import download_audio_from_url, transcribe_audio, analyze_content
from models.classifier import get_spotify_token
from config import SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET

# Configuraci√≥n de logging
logger = logging.getLogger(__name__)

# Manejadores de comandos

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /start."""
    welcome_text = (
        "üëã ¬°Bienvenido al Analizador de Podcasts!\n\n"
        "Puedes usar este bot de dos maneras ü§ñ:\n"
        "1Ô∏è‚É£ Env√≠a el nombre de un podcast para buscar en Spotify\n"
        "2Ô∏è‚É£ Env√≠a directamente la URL de un episodio para analizarlo\n\n"
        "¬øCon qu√© podcast te gustar√≠a comenzar hoy?"
    )
    await update.message.reply_text(welcome_text)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /help."""
    help_text = (
        "üîç *C√≥mo usar el Analizador de Podcasts*\n\n"
        "*Opciones disponibles:*\n"
        "‚Ä¢ Env√≠a el *nombre* de un podcast para buscarlo en Spotify\n"
        "‚Ä¢ Env√≠a una *URL* de un episodio para analizarlo directamente\n\n"
        "*Comandos:*\n"
        "/start - Inicia el bot\n"
        "/help - Muestra este mensaje de ayuda\n\n"
        "*Una vez analizado un podcast, podr√°s ver:*\n"
        "‚Ä¢ üé¨ Resumen Ejecutivo\n"
        "‚Ä¢ üß© An√°lisis por Segmentos\n"
        "‚Ä¢ üí° Recomendaciones"
    )
    await update.message.reply_text(help_text, parse_mode='Markdown')

# Manejadores principales

async def handle_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Punto de entrada unificado para manejar la entrada del usuario.
    Maneja tanto URLs directas como t√©rminos de b√∫squeda.
    """
    text = update.message.text.strip()
    
    try:
        if is_url(text):
            # URL directa: procesar como podcast
            await process_podcast_url(text, update, context)
        else:
            # B√∫squeda por t√©rmino
            await search_podcasts(text, update, context)
            
    except Exception as e:
        logger.error(f"Error al manejar la entrada: {e}", exc_info=True)
        await update.message.reply_text(
            "‚ö†Ô∏è Ocurri√≥ un error inesperado. Por favor, intenta de nuevo m√°s tarde."
        )

async def search_podcasts(query: str, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Busca podcasts en Spotify seg√∫n un t√©rmino de b√∫squeda."""
    await update.message.reply_text("üîç Buscando podcasts relacionados...")
    
    try:
        token = get_spotify_token(SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET)
        results = search_spotify_episodes(query, token)

        if not results:
            await update.message.reply_text("‚ùå No se encontraron resultados. ¬øPuedes intentar con otro nombre?")
            return
        
        # Guardar resultados temporalmente por usuario
        context.user_data["spotify_results"] = results

        # Mostrar nombre del episodio y podcast
        keyboard = [
            [InlineKeyboardButton(
                f"{item.get('episode_title', 'Sin t√≠tulo')} ‚Äì {item.get('podcast_name', 'Sin podcast')}",
                callback_data=f"select_{i}"
            )]
            for i, item in enumerate(results[:MAX_SEARCH_RESULTS])
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Verificar si el teclado tiene opciones
        if keyboard:
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text("Selecciona un podcast para analizar:", reply_markup=reply_markup)
        else:
            await update.message.reply_text("‚ùå No se encontraron episodios en los resultados.")
    
    except Exception as e:
        logger.error(f"Error en la b√∫squeda: {e}", exc_info=True)
        await update.message.reply_text("‚ö†Ô∏è Ocurri√≥ un error durante la b√∫squeda. Intenta de nuevo m√°s tarde.")

async def process_podcast_url(url: str, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Procesa una URL de podcast: descarga, transcribe y clasifica."""
    chat_id = update.effective_chat.id
    
    # Limpiar datos anteriores antes de procesar un nuevo podcast
    context.user_data.pop("classification", None)
    
    try:
        # Mensaje de descarga
        status_message = await context.bot.send_message(
            chat_id=chat_id, 
            text="üì• Descargando el audio..."
        )
        
        # Descargar audio
        success = await download_audio_from_url(url)
        # Fallback a YouTube si es un enlace de Spotify
        if not success and "open.spotify.com" in url:
            # Intentar obtener el nombre del podcast desde los datos guardados
            spotify_results = context.user_data.get("spotify_results", [])
            selected_index = next(
                (i for i, item in enumerate(spotify_results) if item.get("spotify_url") == url),
                None
            )

            if selected_index is not None:
                podcast_name = spotify_results[selected_index].get("episode_title")
                
                youtube_url = f"ytsearch1:{podcast_name}"

                print(f"URL alternativa encontrada en YouTube: {youtube_url}")
                
                if youtube_url:
                    success = await download_audio_from_url(youtube_url)

        if not success:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=status_message.message_id,
                text="‚ö†Ô∏è No pude descargar audio ni desde Spotify ni desde YouTube. Intenta con otro podcast."
            )
            return

        # Actualizar estado a transcripci√≥n
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=status_message.message_id,
            text="Audio descargado.üìù Transcribiendo..."
        )
        
        # Transcribir audio
        transcription = transcribe_audio()
        
        # Actualizar estado a an√°lisis
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=status_message.message_id,
            text="üß† Transcripci√≥n completada. Analizando contenido..."
        )
        
        # Clasificar contenido
        classification = analyze_content(transcription)
        
        # Guardar el resultado completo para este usuario
        store_user_data(chat_id, classification)
        
        # Extraer la secci√≥n de clasificaci√≥n
        summary = extract_section(classification, 1)
        
        # Crear men√∫ de opciones
        keyboard = [
            [InlineKeyboardButton("üé¨ Resumen Ejecutivo", callback_data='resumen')],
            [InlineKeyboardButton("üß© An√°lisis por Segmentos", callback_data='segmentos')],
            [InlineKeyboardButton("üí° Recomendaciones", callback_data='recomendaciones')],
            [InlineKeyboardButton("üéôÔ∏è Analizar nuevo podcast", callback_data='nuevo_podcast')],
            [InlineKeyboardButton("üö™ Terminar", callback_data='fin')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Enviar resultado al usuario
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=status_message.message_id,
            text=f"<b>üéôÔ∏è Clasificaci√≥n del podcast:</b>\n\n{summary}",
            parse_mode='HTML'
        )
        
        # Enviar men√∫ de opciones
        await context.bot.send_message(
            chat_id=chat_id,
            text="¬øQu√© m√°s deseas ver?",
            reply_markup=reply_markup
        )
    
    except Exception as e:
        logger.error(f"Error en el procesamiento: {e}", exc_info=True)
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ö†Ô∏è Ocurri√≥ un error durante el procesamiento. Intenta de nuevo m√°s tarde."
        )

# Manejadores de callbacks

async def handle_podcast_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja la selecci√≥n de un podcast de los resultados de b√∫squeda."""
    query = update.callback_query
    await query.answer()

    if not query.data.startswith("select_"):
        return

    try:
        index = int(query.data.split("_")[1])
        results = context.user_data.get("spotify_results", [])

        if not results or index >= len(results):
            await query.edit_message_text("‚ùå No se pudo recuperar el episodio seleccionado.")
            return

        selected_episode = results[index]
        episode_name = selected_episode.get("episode_title", "Sin nombre")
        podcast_name = selected_episode.get("podcast_name", "Sin nombre")
        external_url = selected_episode.get("spotify_url")

        if not external_url:
            await query.edit_message_text("‚ùå No se pudo obtener la URL del episodio en Spotify.")
            return

        await query.edit_message_text(
            f"üîó Episodio seleccionado: <b>{episode_name}</b>\nPodcast: <b>{podcast_name}</b>\n‚è≥ Procesando...",
            parse_mode='HTML'
        )
        
        # Procesar la URL del podcast seleccionado
        await process_podcast_url(external_url, update, context)

    except Exception as e:
        logger.error(f"Error al procesar la selecci√≥n: {e}", exc_info=True)
        await query.edit_message_text("‚ö†Ô∏è Ocurri√≥ un error. Intenta seleccionar otro podcast.")

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja los botones interactivos del men√∫."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    result = get_user_data(chat_id)
    
    if not result and query.data != "nuevo_podcast":
        await query.edit_message_text("‚ùå No se encontr√≥ informaci√≥n. ¬øPodr√≠as enviar otra URL?")
        return
    
    # Procesar seg√∫n la opci√≥n seleccionada
    if query.data == "resumen":
        text = extract_section(result, 2)
        title = "üé¨ Resumen Ejecutivo"
    elif query.data == "segmentos":
        text = extract_section(result, 3)
        title = "üß© An√°lisis por Segmentos"
    elif query.data == "recomendaciones":
        text = extract_section(result, 4)
        title = "üí° Recomendaciones"
    elif query.data == "nuevo_podcast":
        # Limpiar datos previos del usuario
        clear_user_data(chat_id)
        await query.edit_message_text("¬°Perfecto! Env√≠ame la URL o el nombre del nuevo podcast que quieres analizar.")
        return
    elif query.data == "fin":
        clear_user_data(chat_id)
        await query.edit_message_text("Gracias por usar el analizador de podcasts üéß. ¬°Hasta la pr√≥xima!")
        return
    else:
        text = "Opci√≥n no v√°lida."
        title = "‚ö†Ô∏è Error"
    
    # Formatear el mensaje si es demasiado largo
    text = format_long_message(text)
    
    # Enviar la secci√≥n solicitada
    await query.edit_message_text(f"<b>{title}</b>\n\n{text}", parse_mode='HTML')
    
    # Mostrar botones de nuevo para seguir navegando
    keyboard = [
        [InlineKeyboardButton("üé¨ Resumen Ejecutivo", callback_data='resumen')],
        [InlineKeyboardButton("üß© An√°lisis por Segmentos", callback_data='segmentos')],
        [InlineKeyboardButton("üí° Recomendaciones", callback_data='recomendaciones')],
        [InlineKeyboardButton("üéôÔ∏è Analizar nuevo podcast", callback_data='nuevo_podcast')],
        [InlineKeyboardButton("üö™ Terminar", callback_data='fin')]
    ]
    await query.message.reply_text(
        "¬øDeseas ver otra secci√≥n o analizar un nuevo podcast?",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# Funci√≥n para configurar los manejadores

def setup_handlers(application):
    """Configura los manejadores para el bot."""
    # Comandos b√°sicos
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    
    # Manejar entradas de texto (URLs o t√©rminos de b√∫squeda)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_input))
    
    # Manejar callbacks de selecci√≥n de podcasts 
    application.add_handler(CallbackQueryHandler(handle_podcast_selection, pattern=r'^select_\d+$'))
    
    # Manejar otros callbacks
    application.add_handler(CallbackQueryHandler(button_handler))
    
    return application